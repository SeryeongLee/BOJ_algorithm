"""

1003 : 피보나치 함수
아이디어 - 반복문 사용(재귀함수X)
값이 0과 1일 때는 따로 결과 출력

"""

# 입력
t = int(input()) # 테스트 케이스 개수
n = []
for _ in range(t):
    n.append(int(input()))
def fibo(x):
    if x==0:
        print(1,0)
    elif x==1:
        print(0,1)
    else:
        case = 0
        now = 1
        before = 0
        for i in range(x-1):
            case = now
            now = before + case
            before = case
        print(before,now)



"""
2579 : 계단 오르기

규칙
1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.

아이디어 - 보텀업 방식
마지막 계단(End) 밟았을 시 -> End-1 계단 or End-2 계단 밟을 수 있다.
1) End-1 계단 밟았을 시 -> End-2 계단은 밟으면 안된다.
2) End-2 계단 밟았을 시 -> 상관없음

점화식
ki : i번째 계단에 있는 점수
ai = max(ai-2 + ki , ai-3 + ki-1 + ki)

"""
# 입력 받기
n = int(input())
# 모든 계단 점수 입력받기
scores = [0] * 301
for i in range(n):
    scores[i]=int(input()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 301

# 다이내믹 프로그래밍 진행(보텀업)
# 초기 계단 3개 값 설정
d[0] = scores[0]
d[1] = scores[0]+scores[1]
d[2] = max(scores[1]+scores[2],scores[0]+scores[2])
# 3번째 계단부터 진행
for i in range(3,n):
    d[i] = max(d[i-3] + scores[i-1] + scores[i], d[i-2] + scores[i])

# 계산 결과 출력
print(d[n-1])

"""
10844 : 쉬운 계단 수

문제
45656이란 수를 보자.
이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.
N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

각 자리수에서 맨 뒤에 올수 있는 숫자의 개수(0~9)

                    0  1  2  3  4  5  6  7  8  9
자리수가 1일 때 개수 0  1  1  1  1  1  1  1  1  1
자리수 2            1  1  2  2  2  2  2  2  2  1
자리수 3            1  3  3  4  4  4  4  4  3  2
자리수 4            3  4  7  7  8  8  8  7  6  3

예시) 자리수 3일때
맨 뒤에 0이 올 수 있는 경우 - 210
맨 뒤에 1이 올 수 있는 경우 - 321, 121, 101
맨 뒤 값에 1씩 차이 나는 것만 앞에 올 수 있기 때문에
예를 들어 맨 뒤 값이 1이면 그 앞은 0과 2만 올 수 있다.
따라서 0과 2의 값들의 저장되어 있던 개수들을 더하기

점화식
i : 자리 수
j : 맨 뒤에 갈 수 있는 수(0~9)

1) j = 0 일 때, 오른쪽 대각선만 더하기
aij = a[i-1][j+1] (열은 고정된다.)
aij = a[i-1][1]

2) j = 9 일 때, 왼쪽 대각선만 더하기
aij = a[i-1][j-1]
aij = a[i-1][8]

3) j=2 , ... , 8
aij = a[i-1][j-1] + a[i-1][j+1]

"""
# 입력 받기
n = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [[0] * 10 for i in range(n + 1)]

# 자리 수가 1개 일 때 설정
d[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]


# 다이내믹 프로그래밍 진행
for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            d[i][j] = d[i - 1][1]
        elif j == 9:
            d[i][j] = d[i - 1][8]
        else:
            d[i][j] = d[i - 1][j - 1] + d[i - 1][j + 1]


print(sum(d[n]) % 1000000000)

"""

1912 연속합

점화식
ki : i번째 숫자
현재값이나 그 전 값들과 현재값을 더한것 중 큰 것
ai = max(ki, ai-1+ ki)

"""

# 입력
n=int(input())
array=list(map(int,input().split()))

# dp테이블 초기화
d = [0] * n

# dp 시작값 설정
d[0] = array[0]

for i in range(1,n):
    d[i] = max(array[i], array[i] + d[i-1])

print(max(d))
